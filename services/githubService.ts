import { ProjectBlueprint } from "../types";

export const publishToGitHub = async (token: string, project: ProjectBlueprint): Promise<string> => {
  const headers = {
    'Authorization': `token ${token}`,
    'Accept': 'application/vnd.github.v3+json',
    'Content-Type': 'application/json',
  };

  // 1. Create the repository
  const repoName = project.title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '') + `-starter-${Date.now().toString().slice(-4)}`;

  const createRepoResponse = await fetch('https://api.github.com/user/repos', {
    method: 'POST',
    headers,
    body: JSON.stringify({
      name: repoName,
      description: `${project.description} - Generated by NeuralForge`,
      private: true, // Default to private for safety
      auto_init: true, // Creates an empty README to start
    }),
  });

  if (!createRepoResponse.ok) {
    const err = await createRepoResponse.json();
    throw new Error(err.message || 'Failed to create repository');
  }

  const repo = await createRepoResponse.json();
  const owner = repo.owner.login;

  // Helper to create/update a file
  const createFile = async (path: string, content: string, message: string) => {
    // Get current SHA if file exists (not needed if we know repo is empty, but good practice)
    // Since we used auto_init, README exists, so we need to update it.
    // For new files, we just create.
    
    let sha: string | undefined;
    try {
        const getFile = await fetch(`https://api.github.com/repos/${owner}/${repoName}/contents/${path}`, { headers });
        if (getFile.ok) {
            const fileData = await getFile.json();
            sha = fileData.sha;
        }
    } catch (e) {}

    const body: any = {
        message,
        content: btoa(unescape(encodeURIComponent(content))), // UTF-8 compatible base64
    };
    if (sha) body.sha = sha;

    const res = await fetch(`https://api.github.com/repos/${owner}/${repoName}/contents/${path}`, {
        method: 'PUT',
        headers,
        body: JSON.stringify(body)
    });

    if (!res.ok) {
        console.warn(`Failed to create file ${path}`);
    }
  };

  // 2. Update README.md
  const readmeContent = `# ${project.title}

## Overview
${project.description}

## Machine Learning Domain
${project.domain} (${project.difficulty})

## Core Model
- **ID**: ${project.huggingFaceModel.modelId}
- **Task**: ${project.huggingFaceModel.task}

## Research Paper
${project.paper.title}
${project.paper.authors ? `By ${project.paper.authors}` : ''}

## Implementation Steps
${project.implementationSteps.map((step, i) => `${i + 1}. ${step}`).join('\n')}

## Datasets
${project.datasets.map(d => `- [${d.name}](${d.url || '#'}) (${d.source}): ${d.description}`).join('\n')}

## Generated by NeuralForge
`;

  await createFile('README.md', readmeContent, 'Update README via NeuralForge');

  // 3. Create main.py
  await createFile('main.py', project.pythonSnippet, 'Add starter code via NeuralForge');

  // 4. Create requirements.txt
  const reqs = project.techStack.join('\n');
  await createFile('requirements.txt', reqs, 'Add requirements.txt via NeuralForge');

  return repo.html_url;
};